// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repo_test

import (
	"context"
	"github.com/doyyan/kubernetes/internal/app/domain"
	"github.com/sirupsen/logrus"
	kube "k8s.io/client-go/kubernetes"
	"sync"
)

// K8SMock is a mock implementation of repository.K8S.
//
// 	func TestSomethingThatUsesK8S(t *testing.T) {
//
// 		// make and configure a mocked repository.K8S
// 		mockedK8S := &K8SMock{
// 			CreateDeploymentFunc: func(ctx context.Context, logger *logrus.Logger, d domain.Deployment, clientset *kube.Clientset) error {
// 				panic("mock out the CreateDeployment method")
// 			},
// 			DeleteFunc: func(ctx context.Context, logger *logrus.Logger, deployment domain.Deployment, clientset *kube.Clientset) error {
// 				panic("mock out the Delete method")
// 			},
// 			GetKubeConfigFunc: func() *kube.Clientset {
// 				panic("mock out the GetKubeConfig method")
// 			},
// 			GetRolloutStatusFunc: func(ctx context.Context, logger *logrus.Logger, deployment domain.Deployment, clientset *kube.Clientset) (string, bool, error) {
// 				panic("mock out the GetRolloutStatus method")
// 			},
// 		}
//
// 		// use mockedK8S in code that requires repository.K8S
// 		// and then make assertions.
//
// 	}
type K8SMock struct {
	// CreateDeploymentFunc mocks the CreateDeployment method.
	CreateDeploymentFunc func(ctx context.Context, logger *logrus.Logger, d domain.Deployment, clientset *kube.Clientset) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, logger *logrus.Logger, deployment domain.Deployment, clientset *kube.Clientset) error

	// GetKubeConfigFunc mocks the GetKubeConfig method.
	GetKubeConfigFunc func() *kube.Clientset

	// GetRolloutStatusFunc mocks the GetRolloutStatus method.
	GetRolloutStatusFunc func(ctx context.Context, logger *logrus.Logger, deployment domain.Deployment, clientset *kube.Clientset) (string, bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateDeployment holds details about calls to the CreateDeployment method.
		CreateDeployment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Logger is the logger argument value.
			Logger *logrus.Logger
			// D is the d argument value.
			D domain.Deployment
			// Clientset is the clientset argument value.
			Clientset *kube.Clientset
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Logger is the logger argument value.
			Logger *logrus.Logger
			// Deployment is the deployment argument value.
			Deployment domain.Deployment
			// Clientset is the clientset argument value.
			Clientset *kube.Clientset
		}
		// GetKubeConfig holds details about calls to the GetKubeConfig method.
		GetKubeConfig []struct {
		}
		// GetRolloutStatus holds details about calls to the GetRolloutStatus method.
		GetRolloutStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Logger is the logger argument value.
			Logger *logrus.Logger
			// Deployment is the deployment argument value.
			Deployment domain.Deployment
			// Clientset is the clientset argument value.
			Clientset *kube.Clientset
		}
	}
	lockCreateDeployment sync.RWMutex
	lockDelete           sync.RWMutex
	lockGetKubeConfig    sync.RWMutex
	lockGetRolloutStatus sync.RWMutex
}

// CreateDeployment calls CreateDeploymentFunc.
func (mock *K8SMock) CreateDeployment(ctx context.Context, logger *logrus.Logger, d domain.Deployment, clientset *kube.Clientset) error {
	if mock.CreateDeploymentFunc == nil {
		panic("K8SMock.CreateDeploymentFunc: method is nil but K8S.CreateDeployment was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Logger    *logrus.Logger
		D         domain.Deployment
		Clientset *kube.Clientset
	}{
		Ctx:       ctx,
		Logger:    logger,
		D:         d,
		Clientset: clientset,
	}
	mock.lockCreateDeployment.Lock()
	mock.calls.CreateDeployment = append(mock.calls.CreateDeployment, callInfo)
	mock.lockCreateDeployment.Unlock()
	return mock.CreateDeploymentFunc(ctx, logger, d, clientset)
}

// CreateDeploymentCalls gets all the calls that were made to CreateDeployment.
// Check the length with:
//     len(mockedK8S.CreateDeploymentCalls())
func (mock *K8SMock) CreateDeploymentCalls() []struct {
	Ctx       context.Context
	Logger    *logrus.Logger
	D         domain.Deployment
	Clientset *kube.Clientset
} {
	var calls []struct {
		Ctx       context.Context
		Logger    *logrus.Logger
		D         domain.Deployment
		Clientset *kube.Clientset
	}
	mock.lockCreateDeployment.RLock()
	calls = mock.calls.CreateDeployment
	mock.lockCreateDeployment.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *K8SMock) Delete(ctx context.Context, logger *logrus.Logger, deployment domain.Deployment, clientset *kube.Clientset) error {
	if mock.DeleteFunc == nil {
		panic("K8SMock.DeleteFunc: method is nil but K8S.Delete was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Logger     *logrus.Logger
		Deployment domain.Deployment
		Clientset  *kube.Clientset
	}{
		Ctx:        ctx,
		Logger:     logger,
		Deployment: deployment,
		Clientset:  clientset,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, logger, deployment, clientset)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedK8S.DeleteCalls())
func (mock *K8SMock) DeleteCalls() []struct {
	Ctx        context.Context
	Logger     *logrus.Logger
	Deployment domain.Deployment
	Clientset  *kube.Clientset
} {
	var calls []struct {
		Ctx        context.Context
		Logger     *logrus.Logger
		Deployment domain.Deployment
		Clientset  *kube.Clientset
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// GetKubeConfig calls GetKubeConfigFunc.
func (mock *K8SMock) GetKubeConfig() *kube.Clientset {
	if mock.GetKubeConfigFunc == nil {
		panic("K8SMock.GetKubeConfigFunc: method is nil but K8S.GetKubeConfig was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetKubeConfig.Lock()
	mock.calls.GetKubeConfig = append(mock.calls.GetKubeConfig, callInfo)
	mock.lockGetKubeConfig.Unlock()
	return mock.GetKubeConfigFunc()
}

// GetKubeConfigCalls gets all the calls that were made to GetKubeConfig.
// Check the length with:
//     len(mockedK8S.GetKubeConfigCalls())
func (mock *K8SMock) GetKubeConfigCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetKubeConfig.RLock()
	calls = mock.calls.GetKubeConfig
	mock.lockGetKubeConfig.RUnlock()
	return calls
}

// GetRolloutStatus calls GetRolloutStatusFunc.
func (mock *K8SMock) GetRolloutStatus(ctx context.Context, logger *logrus.Logger, deployment domain.Deployment, clientset *kube.Clientset) (string, bool, error) {
	if mock.GetRolloutStatusFunc == nil {
		panic("K8SMock.GetRolloutStatusFunc: method is nil but K8S.GetRolloutStatus was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Logger     *logrus.Logger
		Deployment domain.Deployment
		Clientset  *kube.Clientset
	}{
		Ctx:        ctx,
		Logger:     logger,
		Deployment: deployment,
		Clientset:  clientset,
	}
	mock.lockGetRolloutStatus.Lock()
	mock.calls.GetRolloutStatus = append(mock.calls.GetRolloutStatus, callInfo)
	mock.lockGetRolloutStatus.Unlock()
	return mock.GetRolloutStatusFunc(ctx, logger, deployment, clientset)
}

// GetRolloutStatusCalls gets all the calls that were made to GetRolloutStatus.
// Check the length with:
//     len(mockedK8S.GetRolloutStatusCalls())
func (mock *K8SMock) GetRolloutStatusCalls() []struct {
	Ctx        context.Context
	Logger     *logrus.Logger
	Deployment domain.Deployment
	Clientset  *kube.Clientset
} {
	var calls []struct {
		Ctx        context.Context
		Logger     *logrus.Logger
		Deployment domain.Deployment
		Clientset  *kube.Clientset
	}
	mock.lockGetRolloutStatus.RLock()
	calls = mock.calls.GetRolloutStatus
	mock.lockGetRolloutStatus.RUnlock()
	return calls
}
